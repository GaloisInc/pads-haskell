{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf350
{\fonttbl\f0\fmodern\fcharset0 CourierNewPSMT;\f1\fmodern\fcharset0 CourierNewPS-BoldMT;\f2\fmodern\fcharset0 CourierNewPS-ItalicMT;
}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww15180\viewh19620\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f0\fs28 \cf0 -- Meta notation: \
--  [ foo ] = zero or one foos\
--  \{ foo \} = any number of foos, including zero\
-- Note that both [] amd \{\} are used as objects when bold, thus 
\f1\b [] \{\}
\f0\b0 \
\
\
-- 
\f1\b Type declarations
\f0\b0 \
\
topdecl	-> 
\f1\b type
\f0\b0     declLHS ptype\
		 | 
\f1\b data
\f0\b0     declLHS dataRHS    [
\f1\b deriving
\f0\b0  derives]\
		 | 
\f1\b newtype
\f0\b0  declLHS newtypeRHS [
\f1\b deriving
\f0\b0  derives]\
		 | 
\f1\b oldtype
\f0\b0  declLHS ptype\
\
declLHS	-> tycon \{tyvar\} [pattern] 
\f1\b =\

\f0\b0 \
\
derives	-> qtycls\
		 | 
\f1\b ( 
\f0\b0 qtycls \{
\f1\b ,
\f0\b0  qtycls\} 
\f1\b )
\f0\b0 \
\
\
-- 
\f1\b type expressions
\f0\b0 \
\
ptype 	-> 
\f1\b constrain 
\f0\b0 pattern 
\f1\b ::
\f0\b0  btype pred			
\f2\i (subtype)
\f0\i0 \
		 | 
\f1\b transform 
\f0\b0 ptype 
\f1\b =>
\f0\b0  ptype 
\f1\b using
\f0\b0  expression	
\f2\i (transformed type)
\f0\i0 \
		 | list [listEnd]\
		 | btype \{
\f1\b -> 
\f0\b0 btype\}						
\f2\i (function)
\f0\i0 \
\
list		-> 
\f1\b [
\f0\b0  ptype [
\f1\b |
\f0\b0  ptype] 
\f1\b ]\

\f0\b0 \
listEnd	-> 
\f1\b terminator
\f0\b0  ptype\
		 | 
\f1\b length 
\f0\b0 expression\
\
pred 	-> 
\f1\b where 
\f0\b0 expression\
\
\
btype	-> etype \{atype\} [expression]	 	 
\f2\i (type application)\

\f0\i0 \
etype	-> atype\
		 | expression\
\
atype	-> 
\f1\b ( 
\f0\b0 ptype \{
\f1\b ,
\f0\b0  ptype\} 
\f1\b )
\f0\b0 				 
\f2\i (parens and tuple type)
\f0\i0 \
		 | list
\f1\b 					
\f0\b0 		
\f2\i  (list type, no qualifiers)
\f0\i0 \
		 | gtycon\
		 | tyvar\
\
gtycon	-> qtycon						 
\f2\i (qualified type consctructor)
\f0\i0 \
		 | 
\f1\b ()
\f0\b0 							 
\f2\i (unit type)\

\f0\i0 		 | 
\f1\b []
\f0\b0 							 
\f2\i (list constructor)
\f0\i0 \
		 | 
\f1\b (->)
\f0\b0 	 						 
\f2\i (function constructor)
\f0\i0 \
		 | 
\f1\b (,
\f0\b0 \{
\f1\b ,
\f0\b0 \}
\f1\b )
\f0\b0 						 
\f2\i (tupling constructors)
\f0\i0 \
\
\
\
-- 
\f1\b data
\f0\b0 \
\
dataRHS	-> constr \{
\f1\b |
\f0\b0  constr\}					 
\f2\i (union)
\f0\i0 \
		 | 
\f1\b case
\f0\b0  expression 
\f1\b of
\f0\b0  branch \{
\f1\b |
\f0\b0  branch\}	 
\f2\i (switch)
\f0\i0 \
\
branch	-> pattern
\f1\b  ->
\f0\b0  constr \
\
constr	-> con \{[
\f1\b !
\f0\b0 ] etype\} [pred]
\f2\i \

\f0\i0 		 | con record [pred]\
		 | conoparg conop conoparg [pred]\
\
conoparg -> etype\
	     | 
\f1\b !
\f0\b0  atype\
\
record 	-> 
\f1\b \{
\f0\b0  [field \{
\f1\b ,
\f0\b0  field\}] 
\f1\b \}
\f0\b0 \
field	-> [var 
\f1\b ::
\f0\b0 ] ftype [pred]\
\
ftype	-> ptype\
		 | 
\f1\b !
\f0\b0  atype\
\
\
\
data Foo = Baz (x::Int) (Int Int where <| c==a+b |>\
\
\
-- 
\f1\b newtype (only one represented type one the constructor)
\f0\b0 \
\
newtypeRHS	 -> con \{expression\} atype \{expression\} [pred]\
			  | con 
\f1\b \{
\f0\b0  \{vtype 
\f1\b ,
\f0\b0 \} var 
\f1\b ::
\f0\b0  ftype \{
\f1\b , 
\f0\b0 vtype\} 
\f1\b \}
\f0\b0  [pred]\
\
vtype	-> ptype\
		 | expression\
\
-- 
\f1\b Expression bits
\f0\b0 \
\
pattern		-> haskellPat 				 
\f2\i (Haskell-parsed pattern)\

\f0\i0 \
expression	-> 
\f1\b <| 
\f0\b0 haskellExp 
\f1\b |>
\f0\b0 			 
\f2\i (Haskell-parsed expression)
\f0\i0 \
			 | literal\
\
literal	-> string\
		 | char\
		 | number\
		 | var\
          | con\
\
\
\
-- 
\f1\b variables etc
\f0\b0 \
\
con		-> conid | 
\f1\b (
\f0\b0  consym 
\f1\b )		
\f0\b0 	
\f2\i  (constructor)
\f0\i0 \
var		-> varid | 
\f1\b (
\f0\b0  varsym 
\f1\b )
\f0\b0 			 
\f2\i (variable)
\f0\i0 \
conop	-> consym | 
\f1\b ` 
\f0\b0 conid 
\f1\b `
\f0\b0 			 
\f2\i (constructor operator)
\f0\i0 \
\
qtycon	-> [modid 
\f1\b .
\f0\b0 ] tycon\
qtycls	-> [modid 
\f1\b .
\f0\b0 ] tycls\
modid	-> conid						 
\f2\i (modules)
\f0\i0 \
tycon	-> conid | 
\f1\b (
\f0\b0  varsym 
\f1\b )
\f0\b0 \
tycls	-> conid\
tyvar	-> varid						 
\f2\i (type variables)
\f0\i0 \
\
\
\
-- 
\f1\b Lexical classes
\f0\b0 \
\
varid								 
\f2\i (variables)
\f0\i0 \
varsym\
conid								 
\f2\i (constructors)
\f0\i0 \
consym\
string\
char\
number\
\
\
\
}